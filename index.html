<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
<title>Flappy Roguelike Futurista</title>
<style>
  :root{
    --neon1:#07f7ff;
    --neon2:#a55bff;
    --neon3:#ff2bd6;
    --bgTop:#050612;
    --bgMid:#070a22;
    --bgBot:#07102f;
  }
  body{
    margin:0;
    overflow:hidden;
    background:#000;
    touch-action:none;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
  }
  canvas{
    display:block;
    margin:auto;
    background: linear-gradient(var(--bgTop), var(--bgMid), var(--bgBot));
  }
</style>
</head>
<body>
<canvas id="game"></canvas>

<script>
/* ============================================================
   FLAPPY ROGUELIKE FUTURISTA (single file)
   - mobile friendly
   - deltaTime
   - rooms (choices)
   - orbe laranja 1/100 -> 3 poderes:
      * Slime 12s: +65% speed, +2 coraÃ§Ãµes
      * Explosivo 12s
      * Super (invencÃ­vel) 16s
   - fundo futurista com prÃ©dios e neon glow
============================================================ */

const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

function resizeCanvas(){
  // FULLSCREEN pra celular
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener("resize", resizeCanvas);
resizeCanvas();

// Evita scroll fantasma
document.body.addEventListener("touchmove", e => e.preventDefault(), { passive:false });

/* ===================== AUDIO (opcional) ===================== */
let audioEnabled = true;
let actx = null;
function beep(freq=440, dur=0.05, type="sine", vol=0.05){
  if(!audioEnabled) return;
  if(!actx) actx = new (window.AudioContext || window.webkitAudioContext)();
  const o = actx.createOscillator();
  const g = actx.createGain();
  o.type = type;
  o.frequency.value = freq;
  g.gain.value = vol;
  o.connect(g); g.connect(actx.destination);
  o.start();
  o.stop(actx.currentTime + dur);
}
window.addEventListener("pointerdown", ()=>{
  if(actx && actx.state==="suspended") actx.resume();
},{once:false});

/* ===================== Helpers ===================== */
const rand = (a,b)=>Math.random()*(b-a)+a;
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const pick = arr => arr[(Math.random()*arr.length)|0];
const chance = p => Math.random() < p;

/* ===================== Game State ===================== */
const G = {
  running: true,
  pausedForChoice: false,
  gameOver: false,

  score: 0,
  coins: 0,
  best: 0,

  baseSpeed: 210, // px/s
  speed: 210,
  tempSpeedMult: 1, // buffs

  gravity: 1220,  // px/s^2
  jumpVel: -400,  // px/s

  pipe: {
    interval: 1.55,
    timer: 0,
    width: 78,
    gap: 175,
    moveChance: 0.22
  },

  roomEvery: 6,
  nextRoomScore: 6,

  shieldBonus: 0,
  coinBonus: 0
};

const bird = {
  x: 110,
  y: canvas.height/2,
  r: 14,
  vy: 0,

  hpMax: 3,
  hp: 3,

  shield: 0,
  iFrames: 0,

  mode: null,      // "explosive" | "super" | "slime"
  modeTime: 0,

  extraJump: 0
};

const pipes = [];
const items = [];
const particles = [];

/* ===================== Futuristic Background ===================== */
const bg = {
  stars: [],
  buildings: [],
  t: 0
};

// estrelas
for(let i=0;i<90;i++){
  bg.stars.push({
    x: Math.random()*canvas.width,
    y: Math.random()*canvas.height*0.6,
    s: rand(0.7,2.2),
    a: rand(0.2,0.9),
    p: rand(0.7,1.6)
  });
}

// prÃ©dios
function rebuildBuildings(){
  bg.buildings = [];
  const horizonY = canvas.height*0.72;
  let x=0;
  while(x < canvas.width+200){
    const w = rand(40,120);
    const h = rand(120, 420);
    bg.buildings.push({
      x,
      y: horizonY,
      w,
      h,
      layer: Math.random()<0.5?1:2,
      neon: pick(["#07f7ff","#a55bff","#ff2bd6"])
    });
    x += w + rand(8,22);
  }
}
rebuildBuildings();

window.addEventListener("resize", rebuildBuildings);

/* ===================== Particles ===================== */
function spawnParticle(x,y, n=8, spread=1){
  for(let i=0;i<n;i++){
    particles.push({
      x,y,
      vx: rand(-160,160)*spread,
      vy: rand(-170,90)*spread,
      r: rand(1.5,3.7),
      life: rand(0.25,0.70),
      neon: chance(0.4)
    });
  }
}

/* ===================== Input ===================== */
function flap(){
  if(G.gameOver){
    resetGame();
    return;
  }
  if(!G.running || G.pausedForChoice) return;

  bird.vy = G.jumpVel - bird.extraJump;
  spawnParticle(bird.x-10, bird.y+8, 8, 1);
  beep(780, 0.04, "square", 0.03);
}

canvas.addEventListener("mousedown", flap);
canvas.addEventListener("touchstart", e => {
  e.preventDefault();
  flap();
},{passive:false});

/* ===================== Reset ===================== */
function resetGame(){
  pipes.length=0; items.length=0; particles.length=0;

  G.running=true;
  G.pausedForChoice=false;
  G.gameOver=false;

  G.score=0; G.coins=0;
  G.baseSpeed=210;
  G.speed=210;
  G.tempSpeedMult=1;

  G.pipe.interval=1.55;
  G.pipe.gap=175;
  G.pipe.timer=0;
  G.pipe.moveChance=0.22;

  G.nextRoomScore=G.roomEvery;

  G.shieldBonus=0;
  G.coinBonus=0;

  bird.y=canvas.height/2;
  bird.vy=0;
  bird.hpMax=3;
  bird.hp=3;

  bird.shield=0;
  bird.iFrames=0;
  bird.mode=null;
  bird.modeTime=0;
  bird.extraJump=0;

  beep(320,0.08,"sine",0.04);
}

/* ===================== Pipes & Items ===================== */
let lastGapY = canvas.height/2;

function spawnPipe(){
  const w = G.pipe.width;

  const gap = clamp(G.pipe.gap, 125, 210);
  const diff = clamp(70 + G.score*1.6, 70, 150);

  let gapY = lastGapY + rand(-diff, diff);
  gapY = clamp(gapY, 110, canvas.height-gap-140);
  lastGapY = gapY;

  const moving = chance(G.pipe.moveChance);

  const pipe = {
    x: canvas.width + 20,
    w,
    gap,
    gapY,
    baseY: gapY,
    moving,
    moveDir: chance(0.5)?1:-1,
    moveSpeed: moving ? rand(32, 70) : 0,
    moveRange: moving ? rand(50, 95) : 0,
    passed: false
  };

  pipes.push(pipe);

  // ORBE LARANJA SUPER RARA: 1 em 100 (1%)
  const itemChance = clamp(0.52 - (G.score*0.012), 0.18, 0.52);

  if(chance(0.01)){
    spawnItemInPipe(pipe, "superOrb"); // ðŸŸ  Ãºnica fonte dos 3 poderes
  } else if(chance(itemChance)){
    spawnItemInPipe(pipe);
  }
}

function spawnItemInPipe(pipe, kind=null){
  if(!kind){
    const r = Math.random();
    if(r < 0.50) kind="coin";
    else if(r < 0.75) kind="shield";
    else kind="perkToken";
  }

  items.push({
    pipe,
    kind,
    x: pipe.x + pipe.w/2,
    y: pipe.gapY + pipe.gap/2,
    r: (kind==="coin")?10 : (kind==="superOrb")?16 : 12,
  });
}

/* ===================== Roguelike Choice System ===================== */
let choiceCards = [];

const RARITY = [
  {name:"Comum", w: 0.62},
  {name:"Raro",  w: 0.28},
  {name:"Ã‰pico", w: 0.10}
];
function rollRarity(){
  const r = Math.random();
  let acc=0;
  for(const t of RARITY){
    acc += t.w;
    if(r<=acc) return t.name;
  }
  return "Comum";
}

function openChoiceRoom(){
  G.pausedForChoice = true;

  // Pool NÃƒO contÃ©m os 3 super poderes
  const pool = [
    {
      id:"hp_up",
      name:"CoraÃ§Ã£o +1",
      desc:"+1 vida mÃ¡xima (cura +1)",
      rarity:"Comum",
      apply: ()=>{
        bird.hpMax += 1;
        bird.hp = Math.min(bird.hpMax, bird.hp+1);
        beep(520,0.07,"sine",0.05);
      }
    },
    {
      id:"shield_long",
      name:"Escudo Prolongado",
      desc:"Escudo coletado dura +2s",
      rarity:"Comum",
      apply: ()=>{
        G.shieldBonus += 2.0;
        beep(560,0.06,"triangle",0.05);
      }
    },
    {
      id:"jump_boost",
      name:"Asas ReforÃ§adas",
      desc:"Pulo mais forte (controle)",
      rarity:"Comum",
      apply: ()=>{
        bird.extraJump += 28;
        beep(660,0.06,"square",0.05);
      }
    },
    {
      id:"slow_world",
      name:"Stabilizer",
      desc:"Reduz velocidade do mundo em 8%",
      rarity:"Raro",
      apply: ()=>{
        G.baseSpeed *= 0.92;
        beep(360,0.08,"sine",0.05);
      }
    },
    {
      id:"coin_bonus",
      name:"MÃ³dulo de GanÃ¢ncia",
      desc:"Moedas valem +1 extra",
      rarity:"Raro",
      apply: ()=>{
        G.coinBonus += 1;
        beep(820,0.06,"triangle",0.05);
      }
    },
    {
      id:"shield_start",
      name:"Bubble Shield",
      desc:"Ganha +2s de escudo agora",
      rarity:"Raro",
      apply: ()=>{
        bird.shield = Math.min(8, bird.shield + 2.0);
        beep(640,0.05,"sine",0.05);
      }
    }
  ];

  choiceCards = [];
  while(choiceCards.length < 3){
    const rarity = rollRarity();
    const options = pool.filter(p=>p.rarity===rarity);
    if(options.length===0) continue;

    const candidate = pick(options);
    if(!choiceCards.find(c=>c.id===candidate.id)) choiceCards.push(candidate);
  }

  // proteÃ§Ã£o rÃ¡pida ao abrir a sala
  bird.shield = Math.max(bird.shield, 0.9);
}

function openSuperOrbChoice(){
  G.pausedForChoice = true;

  // ðŸŸ  LENDÃRIO: sÃ³ pela orbe laranja super rara
  choiceCards = [
    {
      id:"orb_explosive",
      name:"PATO EXPLOSIVO (12s)",
      desc:"Ao colidir, destrÃ³i pipes por 12s",
      rarity:"LENDÃRIO",
      apply: ()=>{
        bird.mode="explosive";
        bird.modeTime=12;
        beep(960,0.08,"square",0.06);
      }
    },
    {
      id:"orb_slime",
      name:"SLIME (12s)",
      desc:"+65% velocidade por 12s, +2 coraÃ§Ãµes",
      rarity:"LENDÃRIO",
      apply: ()=>{
        bird.mode="slime";
        bird.modeTime=12;

        // +2 coraÃ§Ãµes (max e cura)
        bird.hpMax += 2;
        bird.hp = Math.min(bird.hpMax, bird.hp + 2);

        // +65% velocidade temporÃ¡rio
        G.tempSpeedMult = 1.65;

        beep(300,0.08,"triangle",0.06);
      }
    },
    {
      id:"orb_super",
      name:"INVENCIBILIDADE (16s)",
      desc:"VocÃª nÃ£o toma dano por 16s",
      rarity:"LENDÃRIO",
      apply: ()=>{
        bird.mode="super";
        bird.modeTime=16;
        bird.iFrames = Math.max(bird.iFrames, 1.5);
        beep(980,0.08,"sawtooth",0.06);
      }
    }
  ];

  bird.shield = Math.max(bird.shield, 1.0);
}

function handleChoicePick(y){
  const cardH = 102;
  const startY = canvas.height/2 - 185;

  for(let i=0;i<choiceCards.length;i++){
    const cy = startY + i*(cardH+22);
    if(y>=cy && y<=cy+cardH){
      choiceCards[i].apply();
      choiceCards = [];
      G.pausedForChoice = false;
      return;
    }
  }
}

canvas.addEventListener("click",(e)=>{
  if(G.pausedForChoice) handleChoicePick(e.offsetY);
});
canvas.addEventListener("touchstart",(e)=>{
  if(!G.pausedForChoice) return;
  const rect = canvas.getBoundingClientRect();
  const y = e.touches[0].clientY - rect.top;
  handleChoicePick(y);
},{passive:false});

/* ===================== Collision helpers ===================== */
function circleRectCollision(cx,cy,cr, rx,ry,rw,rh){
  const px = clamp(cx, rx, rx+rw);
  const py = clamp(cy, ry, ry+rh);
  const dx = cx-px, dy = cy-py;
  return (dx*dx + dy*dy) <= cr*cr;
}

function takeHit(){
  const inv = (bird.shield>0) || (bird.iFrames>0) || (bird.mode==="super");
  if(inv) return;

  bird.hp -= 1;
  bird.iFrames = 1.05;

  spawnParticle(bird.x, bird.y, 18, 1.7);
  beep(140, 0.09, "sawtooth", 0.06);

  if(bird.hp<=0){
    G.gameOver = true;
    G.running = false;
    G.best = Math.max(G.best, G.score);
    beep(90, 0.25, "square", 0.06);
  }
}

/* ===================== Update (delta time) ===================== */
let lastT = performance.now();

function update(dt){
  if(!G.running) return;
  if(G.pausedForChoice) return;

  bg.t += dt;

  bird.iFrames = Math.max(0, bird.iFrames - dt);
  bird.shield  = Math.max(0, bird.shield - dt);

  if(bird.modeTime > 0){
    bird.modeTime -= dt;
  } else {
    // quando acabar slime, reseta velocidade temporÃ¡ria
    if(bird.mode === "slime"){
      G.tempSpeedMult = 1;
    }
    bird.mode = null;
  }

  // DIFICULDADE
  const diff = clamp(1 + G.score*0.03, 1, 2.8);
  G.speed = G.baseSpeed * diff * (G.tempSpeedMult || 1);
  G.pipe.gap = clamp(175 - G.score*1.2, 132, 175);
  G.pipe.interval = clamp(1.55 - G.score*0.018, 1.00, 1.55);
  G.pipe.moveChance = clamp(0.22 + G.score*0.006, 0.22, 0.55);

  // physics
  bird.vy += G.gravity*dt;
  bird.y += bird.vy*dt;

  // bounds
  if(bird.y + bird.r > canvas.height){
    takeHit();
    bird.y = canvas.height - bird.r;
    bird.vy = -140;
  }
  if(bird.y - bird.r < 0){
    bird.y = bird.r;
    bird.vy = 0;
  }

  // spawn pipes
  G.pipe.timer += dt;
  if(G.pipe.timer >= G.pipe.interval){
    G.pipe.timer = 0;
    spawnPipe();
  }

  // pipes update
  for(let i=pipes.length-1;i>=0;i--){
    const p = pipes[i];
    p.x -= G.speed*dt;

    if(p.moving){
      p.gapY += p.moveSpeed*p.moveDir*dt;
      if(Math.abs(p.gapY - p.baseY) > p.moveRange) p.moveDir *= -1;
    }

    // score
    if(!p.passed && (p.x + p.w < bird.x)){
      p.passed=true;
      G.score++;
      beep(420,0.03,"sine",0.03);

      // abrir sala a cada N pontos
      if(G.score >= G.nextRoomScore){
        G.nextRoomScore += G.roomEvery;
        openChoiceRoom();
      }
    }

    // remove offscreen
    if(p.x + p.w < -100){
      pipes.splice(i,1);
      continue;
    }

    // collision
    const hitTop = circleRectCollision(bird.x,bird.y,bird.r, p.x, 0, p.w, p.gapY);
    const hitBot = circleRectCollision(bird.x,bird.y,bird.r, p.x, p.gapY+p.gap, p.w, canvas.height);

    if(hitTop || hitBot){
      if(bird.mode==="explosive"){
        spawnParticle(p.x+p.w/2, p.gapY+p.gap/2, 28, 2.2);
        pipes.splice(i,1);
        G.coins += 1;
        beep(220,0.06,"square",0.06);
      } else {
        // slime agora NÃƒO paralisa, apenas joga normal (risco maior)
        takeHit();
        bird.vy = -280;
      }
    }
  }

  // items update
  for(let i=items.length-1;i>=0;i--){
    const it = items[i];
    if(!it.pipe || !pipes.includes(it.pipe)){
      items.splice(i,1);
      continue;
    }

    it.x = it.pipe.x + it.pipe.w/2;
    it.y = it.pipe.gapY + it.pipe.gap/2;

    if(it.x < -200){
      items.splice(i,1);
      continue;
    }

    const d = Math.hypot(bird.x-it.x, bird.y-it.y);
    if(d < bird.r + it.r){
      if(it.kind==="coin"){
        G.coins += 1 + (G.coinBonus||0);
        spawnParticle(it.x, it.y, 12, 1.3);
        beep(880,0.03,"triangle",0.05);
      }
      if(it.kind==="shield"){
        bird.shield = Math.min(8, bird.shield + 2.2 + (G.shieldBonus||0));
        spawnParticle(it.x, it.y, 10, 1.1);
        beep(600,0.04,"sine",0.05);
      }
      if(it.kind==="perkToken"){
        openChoiceRoom();
        spawnParticle(it.x, it.y, 18, 1.8);
        beep(760,0.05,"square",0.05);
      }
      if(it.kind==="superOrb"){
        // ðŸŸ  Ãºnica forma de obter poderes
        openSuperOrbChoice();
        spawnParticle(it.x, it.y, 26, 2.4);
        beep(980,0.12,"sawtooth",0.07);
      }

      items.splice(i,1);
    }
  }

  // particles
  for(let i=particles.length-1;i>=0;i--){
    const p = particles[i];
    p.life -= dt;
    p.x += p.vx*dt;
    p.y += p.vy*dt;
    p.vy += 690*dt;
    p.vx *= Math.pow(0.16, dt);
    if(p.life<=0) particles.splice(i,1);
  }

  // stars drift
  for(const s of bg.stars){
    s.x -= (18*s.p + G.speed*0.02)*dt;
    if(s.x < -10) s.x = canvas.width + rand(10, 90);
  }

  // buildings drift
  const horizonY = canvas.height*0.72;
  for(const b of bg.buildings){
    b.y = horizonY;
    b.x -= (G.speed*(b.layer===1?0.08:0.14))*dt;
  }
  // replenish buildings
  if(bg.buildings.length>0){
    const last = bg.buildings[bg.buildings.length-1];
    while(last.x + last.w < canvas.width + 200){
      // no-op
      break;
    }
  }
  // if buildings moved too far left rebuild
  if(bg.buildings.length>0 && bg.buildings[0].x + bg.buildings[0].w < -220){
    rebuildBuildings();
  }
}

/* ===================== Draw Futuristic ===================== */
function neonGlow(color, blur=18){
  ctx.shadowColor = color;
  ctx.shadowBlur = blur;
}

function drawBackground(){
  // stars
  ctx.save();
  for(const s of bg.stars){
    ctx.globalAlpha = s.a * (0.5 + 0.5*Math.sin(bg.t*s.p));
    ctx.fillStyle="#fff";
    ctx.beginPath();
    ctx.arc(s.x, s.y, s.s, 0, Math.PI*2);
    ctx.fill();
  }
  ctx.restore();

  // glow horizon
  ctx.save();
  ctx.globalAlpha = 0.35;
  const horizonY = canvas.height*0.72;
  const grd = ctx.createLinearGradient(0,horizonY-120,0,horizonY+120);
  grd.addColorStop(0,"rgba(7,247,255,0)");
  grd.addColorStop(0.5,"rgba(165,91,255,0.25)");
  grd.addColorStop(1,"rgba(255,43,214,0)");
  ctx.fillStyle=grd;
  ctx.fillRect(0,horizonY-120,canvas.width,240);
  ctx.restore();

  // buildings
  ctx.save();
  for(const b of bg.buildings){
    const topY = b.y - b.h;
    // silhouette
    ctx.globalAlpha = b.layer===1?0.42:0.60;
    ctx.fillStyle = "#070816";
    ctx.fillRect(b.x, topY, b.w, b.h);

    // neon edge
    ctx.globalAlpha = b.layer===1?0.15:0.22;
    neonGlow(b.neon, b.layer===1?10:16);
    ctx.strokeStyle=b.neon;
    ctx.lineWidth=2;
    ctx.strokeRect(b.x+1, topY+1, b.w-2, b.h-2);
    ctx.shadowBlur=0;

    // windows
    ctx.globalAlpha = b.layer===1?0.10:0.15;
    ctx.fillStyle = "#07f7ff";
    const stepX = 14, stepY = 16;
    for(let wx=b.x+8; wx<b.x+b.w-8; wx+=stepX){
      for(let wy=topY+10; wy<b.y-10; wy+=stepY){
        if(Math.random()<0.12){
          ctx.fillRect(wx,wy,5,8);
        }
      }
    }
  }
  ctx.restore();
}

function drawPipes(){
  for(const p of pipes){
    // futurista: torres neon
    ctx.save();
    neonGlow("#07f7ff", 16);

    // top
    ctx.fillStyle="rgba(6, 255, 255, 0.12)";
    ctx.fillRect(p.x,0,p.w,p.gapY);

    // bottom
    ctx.fillRect(p.x,p.gapY+p.gap,p.w,canvas.height);

    // borders
    ctx.shadowBlur = 0;
    ctx.strokeStyle="rgba(7,247,255,.65)";
    ctx.lineWidth=3;
    ctx.strokeRect(p.x,0,p.w,p.gapY);
    ctx.strokeRect(p.x,p.gapY+p.gap,p.w,canvas.height);

    // neon core line
    neonGlow("#a55bff", 12);
    ctx.strokeStyle="rgba(165,91,255,.85)";
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(p.x+p.w*0.5, 0);
    ctx.lineTo(p.x+p.w*0.5, p.gapY);
    ctx.moveTo(p.x+p.w*0.5, p.gapY+p.gap);
    ctx.lineTo(p.x+p.w*0.5, canvas.height);
    ctx.stroke();

    ctx.restore();
  }
}

function drawItems(){
  for(const it of items){
    if(it.kind==="coin"){
      ctx.save();
      neonGlow("#ffd34d", 16);
      ctx.fillStyle="rgba(255,211,77,0.95)";
      ctx.beginPath(); ctx.arc(it.x,it.y,it.r,0,Math.PI*2); ctx.fill();
      ctx.shadowBlur=0;
      ctx.strokeStyle="rgba(255,255,255,.35)";
      ctx.lineWidth=2;
      ctx.stroke();
      ctx.restore();
    } 
    else if(it.kind==="shield"){
      ctx.save();
      neonGlow("#07f7ff", 20);
      ctx.fillStyle="rgba(75,227,255,0.95)";
      ctx.beginPath(); ctx.arc(it.x,it.y,it.r,0,Math.PI*2); ctx.fill();
      ctx.restore();
    } 
    else if(it.kind==="perkToken"){
      ctx.save();
      neonGlow("#a55bff", 20);
      ctx.fillStyle="rgba(181,82,255,0.95)";
      ctx.beginPath(); ctx.arc(it.x,it.y,it.r,0,Math.PI*2); ctx.fill();
      ctx.restore();
    } 
    else if(it.kind==="superOrb"){
      // ðŸŸ  super rara, aura extra
      ctx.save();
      neonGlow("#ff8a2b", 30);
      ctx.fillStyle="rgba(255,138,43,0.95)";
      ctx.beginPath(); ctx.arc(it.x,it.y,it.r,0,Math.PI*2); ctx.fill();

      // aura pulsante
      ctx.globalAlpha=0.35 + 0.25*Math.sin(bg.t*8);
      ctx.strokeStyle="rgba(255,255,255,.7)";
      ctx.lineWidth=2;
      ctx.beginPath(); ctx.arc(it.x,it.y,it.r+7,0,Math.PI*2); ctx.stroke();

      // highlight
      ctx.globalAlpha=0.45;
      ctx.fillStyle="#fff";
      ctx.beginPath(); ctx.arc(it.x-5,it.y-6,it.r*0.38,0,Math.PI*2); ctx.fill();

      ctx.restore();
    }
  }
}

function drawParticles(){
  for(const p of particles){
    ctx.save();
    ctx.globalAlpha = Math.max(0, p.life*1.6);
    if(p.neon){
      neonGlow("#ff2bd6", 18);
      ctx.fillStyle="rgba(255,43,214,0.85)";
    }else{
      ctx.shadowBlur=0;
      ctx.fillStyle="rgba(255,255,255,0.8)";
    }
    ctx.beginPath();
    ctx.arc(p.x,p.y,p.r,0,Math.PI*2);
    ctx.fill();
    ctx.restore();
  }
}

function drawBird(){
  let body = "#ffd34d";
  if(bird.mode==="super") body = "#86ffcc";
  if(bird.mode==="explosive") body = "#ff6b6b";
  if(bird.mode==="slime") body = "#7fff76";

  // blink iFrames
  if(bird.iFrames>0 && Math.floor(performance.now()/80)%2===0){
    ctx.globalAlpha=0.35;
  }

  ctx.save();
  neonGlow("#07f7ff", 14);

  // body neon
  ctx.fillStyle=body;
  ctx.beginPath(); ctx.arc(bird.x,bird.y,bird.r,0,Math.PI*2); ctx.fill();

  // wing
  ctx.shadowBlur=0;
  ctx.fillStyle="rgba(255,255,255,.75)";
  ctx.beginPath();
  ctx.ellipse(bird.x-6, bird.y+3, 9, 6, Math.sin(performance.now()/130)*0.35, 0, Math.PI*2);
  ctx.fill();

  // eye
  ctx.fillStyle="#0b0b16";
  ctx.beginPath(); ctx.arc(bird.x+5,bird.y-3,2.4,0,Math.PI*2); ctx.fill();

  // beak
  ctx.fillStyle="#ff8a2b";
  ctx.beginPath();
  ctx.moveTo(bird.x+10, bird.y+1);
  ctx.lineTo(bird.x+18, bird.y+4);
  ctx.lineTo(bird.x+10, bird.y+7);
  ctx.closePath();
  ctx.fill();

  // shield ring
  if(bird.shield>0){
    neonGlow("#07f7ff", 18);
    ctx.strokeStyle="rgba(75,227,255,.9)";
    ctx.lineWidth=3;
    ctx.beginPath(); ctx.arc(bird.x,bird.y,bird.r+7,0,Math.PI*2); ctx.stroke();
  }

  ctx.restore();
  ctx.globalAlpha=1;
}

function drawHUD(){
  ctx.save();
  ctx.fillStyle="rgba(0,0,0,.35)";
  ctx.fillRect(12,12, 228, 92);

  ctx.fillStyle="#fff";
  ctx.font="16px Arial";
  ctx.fillText("Score: " + G.score, 24, 38);
  ctx.fillText("Moedas: " + G.coins, 24, 60);
  ctx.fillText("Best: " + G.best, 24, 82);

  // hearts
  for(let i=0;i<bird.hpMax;i++){
    const x = canvas.width - 22 - i*22;
    const y = 26;
    ctx.fillStyle = (i<bird.hp) ? "#ff2bd6" : "rgba(255,255,255,.2)";
    neonGlow("#ff2bd6", (i<bird.hp)?12:0);
    ctx.beginPath(); ctx.arc(x,y,8,0,Math.PI*2); ctx.fill();
    ctx.shadowBlur=0;
  }

  if(bird.mode){
    ctx.fillStyle="rgba(0,0,0,.35)";
    ctx.fillRect(12, 114, 228, 32);
    ctx.fillStyle="#fff";
    ctx.font="14px Arial";
    ctx.fillText("Modo: "+bird.mode+" ("+Math.ceil(bird.modeTime)+"s)", 24, 136);
  }

  ctx.restore();
}

function drawChoiceOverlay(){
  ctx.fillStyle="rgba(0,0,0,0.78)";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  ctx.save();
  neonGlow("#a55bff", 18);
  ctx.fillStyle="rgba(165,91,255,.20)";
  ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.restore();

  ctx.fillStyle="#fff";
  ctx.font="22px Arial";
  ctx.fillText("ESCOLHA UM UPGRADE", 26, canvas.height/2 - 230);

  const startY = canvas.height/2 - 185;
  const cardH = 102;

  for(let i=0;i<choiceCards.length;i++){
    const c = choiceCards[i];
    const y = startY + i*(cardH+22);

    let col = "#bdbdbd";
    if(c.rarity==="Raro") col="#07f7ff";
    if(c.rarity==="Ã‰pico") col="#ff2bd6";
    if(c.rarity==="LENDÃRIO") col="#ff8a2b";

    ctx.save();
    neonGlow(col, 18);
    ctx.fillStyle="rgba(255,255,255,.10)";
    ctx.fillRect(22, y, canvas.width-44, cardH);

    ctx.fillStyle=col;
    ctx.fillRect(22, y, 10, cardH);

    ctx.shadowBlur=0;
    ctx.fillStyle="#fff";
    ctx.font="18px Arial";
    ctx.fillText(c.name, 46, y+36);

    ctx.font="14px Arial";
    ctx.fillStyle="rgba(255,255,255,.85)";
    ctx.fillText(c.desc, 46, y+64);

    ctx.restore();
  }

  ctx.fillStyle="rgba(255,255,255,.75)";
  ctx.font="14px Arial";
  ctx.fillText("Toque em uma carta para continuar", 26, canvas.height - 50);
}

function drawGameOver(){
  ctx.fillStyle="rgba(0,0,0,0.72)";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  ctx.save();
  neonGlow("#ff2bd6", 26);
  ctx.fillStyle="rgba(255,43,214,.18)";
  ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.restore();

  ctx.fillStyle="#ff2bd6";
  ctx.font="34px Arial";
  ctx.fillText("GAME OVER", canvas.width/2 - 110, canvas.height/2 - 80);

  ctx.fillStyle="#fff";
  ctx.font="20px Arial";
  ctx.fillText("Score: " + G.score, canvas.width/2 - 50, canvas.height/2 - 32);
  ctx.fillText("Best: " + G.best, canvas.width/2 - 45, canvas.height/2 + 0);

  ctx.font="15px Arial";
  ctx.fillStyle="rgba(255,255,255,.85)";
  ctx.fillText("Toque/clique para reiniciar", canvas.width/2 - 106, canvas.height/2 + 56);

  ctx.fillStyle="rgba(255,255,255,.55)";
  ctx.fillText("ðŸŸ  Orbe laranja (1/100) concede poderes lendÃ¡rios.", canvas.width/2 - 170, canvas.height/2 + 90);
}

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawBackground();
  drawPipes();
  drawItems();
  drawParticles();
  drawBird();
  drawHUD();

  if(G.pausedForChoice) drawChoiceOverlay();
  if(G.gameOver) drawGameOver();
}

/* ===================== Main Loop ===================== */
function loop(t){
  const dt = Math.min(0.033, (t-lastT)/1000);
  lastT = t;

  update(dt);
  draw();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>
