<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Flappy Roguelike</title>
<style>
body {
    margin: 0;
    background: #111;
    color: white;
    font-family: Arial, sans-serif;
    text-align: center;
    overscroll-behavior: none;
    touch-action: none;
}
canvas {
    display: block;
    margin: auto;
    background: linear-gradient(#4ec0ca, #87ceeb);
}
</style>
</head>
<body>

<h3>üê§ Flappy Roguelike</h3>
<canvas id="game"></canvas>
<p id="hud"></p>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

function resizeCanvas() {
    canvas.width = Math.min(window.innerWidth, 420);
    canvas.height = window.innerHeight - 80;
}
window.addEventListener("resize", resizeCanvas);
resizeCanvas();

let bird, pipes, items, frame, score;
let gravity, jump, speed;
let shieldTime = 0;
let choosingPerk = false;
let perkChoices = [];

const perkPool = [
    { name: "Asas Fortes", desc: "Pulo mais forte", apply: () => jump -= 0.8 },
    { name: "Corpo Leve", desc: "Menos gravidade", apply: () => gravity -= 0.06 },
    { name: "Adrenalina", desc: "Canos mais r√°pidos", apply: () => speed += 0.3 }
];

function resetGame() {
    bird = { x: 90, y: canvas.height / 2, vy: 0, r: 14, rot: 0 };
    pipes = [];
    items = [];
    frame = 0;
    score = 0;
    gravity = 0.5;
    jump = -7;
    speed = 2;
    shieldTime = 0;
    choosingPerk = false;
}

function randomSafeY() {
    const top = 80;
    const bottom = 120;
    return Math.random() * (canvas.height - top - bottom) + top;
}

function flap() {
    if (!choosingPerk) bird.vy = jump;
}

document.addEventListener("keydown", flap);
canvas.addEventListener("mousedown", flap);
canvas.addEventListener("touchstart", e => {
    e.preventDefault();
    flap();
}, { passive: false });

function spawnPipe() {
    const gap = Math.max(90, 150 - score * 2);
    pipes.push({
        x: canvas.width,
        w: 50,
        top: Math.random() * 200 + 60,
        gap,
        type: Math.random() > 0.8 ? "moving" : "normal",
        offset: Math.random() * Math.PI,
        passed: false
    });
}

function spawnItem() {
    items.push({
        x: canvas.width,
        y: randomSafeY(),
        r: 12,
        kind: Math.random() < 0.6 ? "perk" : "shield"
    });
}

function startPerkChoice() {
    choosingPerk = true;
    perkChoices = [];
    while (perkChoices.length < 2) {
        const p = perkPool[Math.floor(Math.random() * perkPool.length)];
        if (!perkChoices.includes(p)) perkChoices.push(p);
    }
}

function update() {
    if (choosingPerk) return;

    frame++;
    bird.vy += gravity;
    bird.y += bird.vy;
    bird.rot = Math.max(-0.5, Math.min(0.5, bird.vy * 0.05));

    if (frame % 90 === 0) spawnPipe();
    if (frame % 220 === 0) spawnItem();

    for (let p of pipes) {
        p.x -= speed;
        if (p.type === "moving") p.offset += 0.03;

        if (!p.passed && p.x + p.w < bird.x) {
            score++;
            p.passed = true;
        }

        if (shieldTime <= 0 && collidePipe(p)) gameOver();
    }

    for (let i of items) {
        i.x -= speed;
        if (dist(bird.x, bird.y, i.x, i.y) < bird.r + i.r) {
            if (i.kind === "shield") shieldTime = 180;
            if (i.kind === "perk") startPerkChoice();
            i.x = -100;
        }
    }

    if (shieldTime > 0) shieldTime--;
    pipes = pipes.filter(p => p.x > -100);
    items = items.filter(i => i.x > -100);

    if (bird.y < 0 || bird.y > canvas.height) gameOver();
}

function collidePipe(p) {
    let top = p.top;
    if (p.type === "moving") top += Math.sin(p.offset) * 40;

    return (
        hit(bird, p.x, 0, p.w, top) ||
        hit(bird, p.x, top + p.gap, p.w, canvas.height)
    );
}

function hit(b, x, y, w, h) {
    return b.x + b.r > x && b.x - b.r < x + w && b.y + b.r > y && b.y - b.r < y + h;
}

function dist(x1,y1,x2,y2){ return Math.hypot(x1-x2,y1-y2); }

function drawBird() {
    ctx.save();
    ctx.translate(bird.x, bird.y);
    ctx.rotate(bird.rot);

    if (shieldTime > 0) {
        ctx.strokeStyle = "rgba(0,200,255,0.7)";
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.arc(0,0,bird.r+6,0,Math.PI*2);
        ctx.stroke();
    }

    ctx.fillStyle = "yellow";
    ctx.beginPath();
    ctx.arc(0,0,bird.r,0,Math.PI*2);
    ctx.fill();

    ctx.fillStyle = "black";
    ctx.beginPath();
    ctx.arc(4,-4,2,0,Math.PI*2);
    ctx.fill();

    ctx.fillStyle = "orange";
    ctx.beginPath();
    ctx.moveTo(bird.r,0);
    ctx.lineTo(bird.r+6,2);
    ctx.lineTo(bird.r+6,-2);
    ctx.fill();

    ctx.restore();
}

function drawPerkMenu() {
    ctx.fillStyle = "rgba(0,0,0,0.7)";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    perkChoices.forEach((p,i)=>{
        const y = 200 + i*120;
        ctx.fillStyle = "#6a00cc";
        ctx.fillRect(40,y,canvas.width-80,80);

        ctx.fillStyle = "white";
        ctx.font = "18px Arial";
        ctx.fillText(p.name, 60, y+30);
        ctx.font = "14px Arial";
        ctx.fillText(p.desc, 60, y+55);
    });
}

canvas.addEventListener("click", e=>{
    if(!choosingPerk) return;
    perkChoices.forEach((p,i)=>{
        const y=200+i*120;
        if(e.offsetY>y && e.offsetY<y+80){
            p.apply();
            choosingPerk=false;
        }
    });
});

function draw() {
    ctx.clearRect(0,0,canvas.width,canvas.height);

    ctx.fillStyle="green";
    for(let p of pipes){
        let top=p.top;
        if(p.type==="moving") top+=Math.sin(p.offset)*40;
        ctx.fillRect(p.x,0,p.w,top);
        ctx.fillRect(p.x,top+p.gap,p.w,canvas.height);
    }

    for(let i of items){
        ctx.fillStyle = i.kind==="shield"?"#00c8ff":"#a020f0";
        ctx.beginPath();
        ctx.arc(i.x,i.y,i.r,0,Math.PI*2);
        ctx.fill();
    }

    drawBird();
    if(choosingPerk) drawPerkMenu();

    document.getElementById("hud").innerText =
        `Score: ${score} | Escudo: ${Math.ceil(shieldTime/60)}s`;
}

function gameOver(){
    alert("Game Over! Score: "+score);
    resetGame();
}

function loop(){
    update();
    draw();
    requestAnimationFrame(loop);
}

resetGame();
loop();
</script>
</body>
</html>
